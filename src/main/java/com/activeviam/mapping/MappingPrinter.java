/*
 * (C) ActiveViam 2023
 * ALL RIGHTS RESERVED. This material is the CONFIDENTIAL and PROPRIETARY
 * property of ActiveViam. Any unauthorized use,
 * reproduction or transfer of this material is strictly prohibited
 */

package com.activeviam.mapping;

import com.activeviam.util.MigrationUtils;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;

/**
 * Helper class to print a {@link Mapping} generated by {@link MappingGenerator}.
 *
 * @author ActiveViam
 */
public class MappingPrinter {

	private static final Logger LOGGER = Logger.getLogger(MappingPrinter.class.getName());

	/**
	 * The {@link PrintMode mode} used when printing a {@link Mapping} with
	 * {@link MappingGenerator#generateMapping(String, String, String)}.
	 */
	public static PrintMode PRINT_MODE = PrintMode.PRINT_WITH_LIMIT;

	/**
	 * The maximal number of mapping entries to print for {@link PrintMode#PRINT_WITH_LIMIT}.
	 */
	public static int PRINT_LIMIT = 20;

	/**
	 * Different ways to print the {@link Mapping}.
	 *
	 * @author ActiveViam
	 */
	public enum PrintMode {
		NO_PRINT,
		PRINT_SUMMARY,
		PRINT_WITH_LIMIT,
		FULL_PRINT
	}

	/**
	 * Prints the given {@link Mapping}.
	 */
	public static void printMapping(final Mapping mapping) {
		switch (PRINT_MODE) {
			case NO_PRINT:
				break;

			case PRINT_SUMMARY:
				printSummary(mapping.getInfo());
				break;

			case PRINT_WITH_LIMIT:
				printMappingValues(mapping.getMapping(), PRINT_LIMIT);
				printSummary(mapping.getInfo());
				break;

			case FULL_PRINT:
				printMappingValues(mapping.getMapping(), -1);
				printSummary(mapping.getInfo());
				break;

			default:
				throw new IllegalStateException("Unrecognized print mode: " + PRINT_MODE);
		}
	}

	private static void printSummary(final MappingInfo mappingInfo) {
		LOGGER.log(Level.INFO, mappingInfo::toString);
	}

	private static void printMappingValues(final Map<String, String> mapping, final int limit) {
		if (limit < 0 || mapping.size() <= limit) {
			// No limit, print all
			LOGGER.log(Level.INFO, () -> {
				final StringBuilder sb = new StringBuilder("Mapping=[");
				mapping.forEach(
						(oldPath, newPath) -> sb.append(MigrationUtils.LINE_SEPARATOR)
								.append("\t")
								.append(oldPath)
								.append(" -> ")
								.append(newPath));
				return sb.append("]").toString();
			});
		} else {
			LOGGER.log(Level.INFO, () -> {
				final StringBuilder sb = new StringBuilder("Mapping=[").append(MigrationUtils.LINE_SEPARATOR);
				Stream.of(mapping.entrySet().toArray(Map.Entry[]::new))
						.limit(limit)
						.forEach(
								entry -> sb.append("\t")
										.append(entry.getKey())
										.append(" -> ")
										.append(entry.getValue())
										.append(MigrationUtils.LINE_SEPARATOR));
				return sb.append("\t...]").toString();
			});
		}
	}

}
